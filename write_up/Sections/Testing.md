# Testing
## Test Coverage
In order to ensure that I have a robust technical solution, I have an extensive unit testing framework to cover the three most technically challenging areas of my program - the `transaction`, `crypto` and `simplify` modules. Across the three, I have 80% coverage, meeting the industry standard. The `crypto` module has >90% coverage. I will include the unit test results in this section. They were generated by my IDE and Python's `unittest` framework, so I could not associate them with my requirements exactly.

However, below the evidence of my tests passing is a link of unit tests to requirements. I have more unit tests than requirements as a byproduct of ensuring that my code is as robust as possible.

As is shown below, I was able to entirely complete my project, fulfilling all of my initial requirements.


## Requirements
These are the same as in the Analysis section
#### RSA Implementation (A)
 1) A reliable interface to a hashing module
 
 2) RSA Key Handling:
	 1) Be able to load RSA public/private keys in PEM format from files / STDIN
	 2) Be able to validate the format of these keys
	 3) Be able to parse these keys extracting all necessary numbers for RSA decryption
 
 3) Signing/Verification
	 1) Have a valid RSA encryption scheme (encryption with public key)
	 2) Have a valid RSA decryption scheme (decryption with private key)
	 3) Have a valid RSA signing (sig) scheme (signing with private key)
	 4) Have a valid RSA signature verification (verif) scheme (verify with public key)
 
 4) Object Signing
	 1) Algorithm to convert an object to a hash in a reproducible way, minimising the chance of hash collisions
	 2) Ability to sign a class of object with RSA sig scheme
	 3) Ability to verify a signed object with RSA verif scheme, raising an error if signature is invalid

#### Debt Simplification (B)
1) A reliable digraph structure, with operations to `transactions.graph.GenericDigraph`
	1) Get the nodes in the graph `nodes()`
	2) Check if an edge exists between two nodes
	3) Nodes can be added
	4) Nodes can be removed
	5) Edges can be added
	6) Edges can be removed
	7) Neighbours of a node should be easily accessed (neighbours for the purposes of a breadth first search)

2) A reliable flow graph structure
	1) All of the operations listed in B.1.1
	2)  Adding an edge should have different functionality: edge should be able to be added with a capacity, and edges should have a notion of flow and unused capacity
	3) Be able to return neighbours of nodes in the residual graph (i.e. edges, including residual edges, that have unused capacity)
	4) A way to get the bottleneck value of a path, given a path of nodes

3) A reliable recursive BFS that works on
	1) Digraphs
	3) Flow Graphs

4) Implementation of Edmonds-Karp
	1) Way to find shortest augmenting path between two nodes
	2) Way to find bottleneck value of a path
	3) Finding max flow along a flow graph from source node to sink node

5) Simplifying an entire graph using Edmonds Karp, using the method laid out in [[#Settling a graph using a Max Flow algorithm]]. 

6) Be able to convert a list of valid transactions into a flow graph 

7) Be able to convert a flow graph into a list of transactions, signed by the server 

8) Be able to simplify a group of transactions, having each transaction individually verified before settling

#### Client / Server Structure (C)
1) The server should be accessible to the client via a REST API
2) The client should be relatively thin, only dealing with input from user and handling error 400 and 500 codes gracefully.
3) The server should be able to pull a group's transactions from a database, run the settling, and handle any requests from the client 
4) The client should be able to request 
	1) See their own user information
		1) Total debt across all groups
		2) Open transactions
		3) Closed transactions
	2) Open transactions / closed transactions
	3) Mark a transaction as settled
	4) Make / invite people /  leave groups
	5) Settle a group
	6) Create a transaction
	7) Sign an open transaction
	8) Mark a transaction as settled

5) Ancillary functions should allow users to:
	   1) Register for an account, giving email, name RSA private key in PEM format and a password
	   2) A `whois` function, allowing you to see people's user info (name, email, public key)
	   3) Create groups with a name and password
	   4) Join groups by ID

#### Command Line Interface (D)
1) Everything listed in C.3

#### Database Architecture (E)
1) User information
	1) User ID
	2) Contact info
	3) Associated Groups
	4) Public Key
2) Transaction Information
	1) Transaction ID
	2) Payee
	3) Recipient
	4) Transaction reference
	5) Amount (Â£)
	6) Payee's signature
	7) Recipient's signature
	8) Whether or not transaction has been settled
3)  Group information
	1) Group name
	2) People in the group
	3) Transactions in the group



## Evidence of fulfilling A & B

![[Pasted image 20220321000032.png]]
![[Pasted image 20220321000057.png]]
![[Pasted image 20220321000126.png]]
![[Pasted image 20220321000146.png]]
![[Pasted image 20220321000210.png]]
![[Pasted image 20220321000325.png]]
![[Pasted image 20220321000346.png]]
![[Pasted image 20220321000412.png]]


![[test plan.png]]

Hence, I am able to prove that not only have I achieved every requirement that I set out to under sections A & B, my extensive unit testing goes a long way to prove the robustness of my solution. 

To show a visual proof of the correctness of my user-defined settling algorithm, I will provide some screenshots produced by test B5 (`test_flow.TestMaxFlow`). These graphs were generated during the running of the test - an artefact of the debugging process. However, I believe that they effectively show that I am able to simplify the chains of debt in a group.

Pre setting: 
![[pre_settle0.svg|500]]

Post settling:
![[settled0.svg|400]]

This is the same example system that I presented in my analysis section.

This is a debugging representation of a flow graph, hence the flows, capacities and residual edges (in red). However, it appropriately demonstrates that my technical solution is able to achieve its objective of simplifying groups of debt. 

My unit tests, included at the end of this section, are more extensive than this one example. They are configured to check that flags are raised when the graph doesn't change, that it doesn't change when it shouldn't, and that the algorithm lends itself well to larger graphs.

During testing, I discovered that this algorithm was more effective on densely populated graphs (more on this in the Evaluation). This solution ended up being an excellent heuristic model to solve my problem. 


## Evidence of fulfilling Section C & D
A demonstration of creating groups (C4.4), joining groups ()
![[Pasted image 20220322124639.png]]

Below is a small sample of the server-generated logs. These exist to show the fulfilment of C1.
Such as with the graphs generated by the debt simplification algorithm, I had implemented these logs for debugging purposes. They also help ensure that my application is robust. 
(red log messages here are still pushed to STDOUT, not STDERR)
![[Pasted image 20220322130304.png]]

Trying to settle the group as it is gives the message:
![[Pasted image 20220322125424.png]]

This is intentional - if there is only one transaction in the group, no chains of debt can be simplified





In order to prove that the debt simplification feature works, 
![[Pasted image 20220322150628.png]]
![[Pasted image 20220322150655.png]]

This second screenshot shows that authorisation methods I have implemented are working - both password incorrect and discrepancies in provided key vs registered key are flagged to the user.

The user also cannot 'double sign' a transaction - upon attempting, 
![[Pasted image 20220322150914.png]]

Showing the groups settling as a whole:
![[Pasted image 20220322151953.png]]


## Evidence of fulfilling Section E

To show that I am able to store everything that I wanted to, as outlined in Section E, I will insert screenshots of my working database tables. 

#### E1 - User information
USERS table (E1, E2, E3)
![[Pasted image 20220322101214.png]]

GROUP_LINK table (E4)
![[Pasted image 20220322101712.png]]

KEYS table (E5)
![[Pasted image 20220322101248.png]]
(note: all the public exponents (e) are the same. This is not an error - RSA guidelines state that the public exponent generated with keys is normally 65537 by convention. In hex, this is $0\ce{x}10001$).
While no users here have multiple public keys, all key information has been normalised out to allow for this in the future while maintaining database integrity and a normalised structure

#### E2 - Transaction Information
The following two screenshots provides evidence for E2.1,  E2.4 -> E2.8
![[Pasted image 20220322103531.png]] 
![[Pasted image 20220322103551.png]]

The evidence for E2.2 and E2.3 is provided below
![[Pasted image 20220322103826.png]]

This is a link table associating pairs of people together (order of a pair matters, i.e. the row 20, 21 is different from 21, 20)
This was done to allow pairs of people to have multiple transactions, maintaining a normalised structure and ensuring data integrity.

### E3 - Group Informaton
Groups Table: This satisfies require E3.1, E3.2
![[Pasted image 20220322104047.png]]
Group Link Table: This satisfies E3.3
![[Pasted image 20220322104009.png]]

Requirement E3.4 is satisfied by this column in the transactions table
![[Pasted image 20220322104241.png]]

Thus, the entirety of my requirements under Section E have been achieved. 

